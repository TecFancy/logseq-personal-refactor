## 💼 Work Stream
- 09:15 [[CTW]] BPM-A(Team2) daily standup #meeting
- 14:00 [[CTW]] Case Tracker UI review #meeting
- DONE [[CTW]] Document PiP investigation #coding
  id:: 695e80ed-36c2-4cc3-a292-79ffd421274a
  collapsed:: true
	- 核心支持能力
		- 完整交互：支持点击、输入、滚动等所有标准网页交互
		- React 兼容：结合 `createPortal` 可将组件“传送到” PiP 窗口，不需要销毁重建
			- 状态保留：表单中已经输入的文字、计数器读数等能保留
			- 响应式更新：主窗口的 state 变化会实时驱动 PiP 窗口内的 UI 更新
		- 动态尺寸调整
			- 支持通过 `resizeTo` 在事件中调整 PiP 窗口大小
			- 窗口尺寸控制：必须由用户手势 (比如 click 事件) 直接触发
				- 不能在 `useEffect` 或异步回调中随意调整 PiP 窗口大小 (浏览器会拦截)
				- 必须直接绑定在 `click` 等事件处理函数中
	- 限制
		- 关闭、刷新主窗口标签，PiP 窗口会强制关闭
		- 浏览器记忆机制
			- 浏览器会优先记住用户上次关闭窗口时的大小和位置，会忽略 `requestWindow` 中的初始配置
				- 比如希望能以高 `32px` 打开窗口，但如果用户上次将窗口拉大到了 `500px`，下次打开依然是 `500px`
				- 方案：不强行重置业务状态，让业务状态适配窗口 (比如上次关闭窗口时展开了表单，下次打开窗口直接显示展开状态的表单)
		- 系统最小高度：操作系统对窗口有强制最小高度 (约 100px - 130px)
			- 初始化配置 32px 高度，实际可能有部分空白
			- 方案：调整最小 panel 的高度
		- 样式隔离
			- 样式不继承
				- PiP 窗口是一个全新的 `window` 上下文，主窗口的 CSS 不会**自动生效**
				- 方案：在打开窗口时，需要手动遍历 `document.styleSheets` 并复制到 PiP 文档的 `<head>` 中
- [[Prepare Interview Materials]] Level 2 (中级开发)
  collapsed:: true
	- **整体要求：不仅能独立完成需求，还能写出可维护的代码，还要理解背后的原理和工程规范。**
	- React 基础
	  collapsed:: true
		- 在 TS 中，为什么要避免对组件的 props 使用 any 类型？
		  logseq.order-list-type:: number
			- 失去 TS 的类型检查优势
			- 父组件传参错误（如拼写错误、类型不匹配）时无法在编译期发现
			- 编辑器丢失智能提示
			- 降低开发效率和代码可读性、增加低级错误出现的概率
		- 解释 `useState` 和 `useEffect` 的典型使用场景，并各举一个实际的例子。
		  logseq.order-list-type:: number
			- `useState`：管理组件内部状态
				- 控制 Modal 的 `isOpen`
				- 或表单输入的 `value`
			- `useEffect`：处理副作用
				- 组件挂载后发起 API 请求
				- 手动操作 DOM (如聚焦输入框)
				- 建立/清除定时器。
	- TypeScript
	  collapsed:: true
		- 什么时候使用 interface，什么时候使用 type 定义类型？它们在扩展性和可维护性上有什么区别？
		  logseq.order-list-type:: number
			- 很多场景通用两者通用，库开发 interface 便于扩展，复杂类型组合逻辑中用 type
			- Interface
				- 适合定义对象结构、类的实现。支持**声明合并**，可扩展第三方库类型
			- Type
				- 更灵活，适合定义基本类型的别名、联合类型、交叉类型、元组等
		- TS 内置类型中，你最常用的有哪些？从你用过的内置类型中你学到了什么？
		  logseq.order-list-type:: number
			- 常见：`Partial`, `Required`, `Pick`, `Omit`, `Record`, `ReturnType`
			- 理解泛型和映射类型的组合能力，能减少重复代码定义
	- 样式与 SCSS
	  collapsed:: true
		- 相比全局 CSS，CSS Module 有哪些优势？
			- 避免命名冲突：自动生成唯一类名，避免污染全局
			- 明确依赖：样式文件与组件一一对应，删除组件时能清楚知道哪些样式也可以删除
	- 单元测试
	  collapsed:: true
		- 什么是 Jest 快照测试？它适用于哪些场景？又有哪些局限性？
		  logseq.order-list-type:: number
			- 将组件渲染结果序列化为字符串并保存在文件中，下次测试时对比是否变化
			- 场景
				- 适用于 UI 结构相对稳定
				- 确保重构时不意外改变 DOM 结构
			- 局限
				- 极其脆弱，任何细微改动都会报错
				- 开发者容易养成“无脑更新快照”的坏习惯，导致测试失效
		- 如果 UI 微调导致大量快照失效，你是选择更新快照还是改用其他测试方式？为什么？
		  logseq.order-list-type:: number
			- 如果是预期的 UI 变更，使用 `u` 更新快照；如果逻辑变更但不应该影响 UI 导致的快照的失效，要通过对比排查 Bug
			- 如果快照过于频繁变动导致维护成本过高，可改用基于 React Testing Library 的断言来测试核心交互，而非全量快照
		- 什么时候需要对自定义 Hook 或函数进行 mock？
		  logseq.order-list-type:: number
			- 涉及外部依赖（API 请求）
			- 涉及不确定性（如 `Date.now()`, `Math.random()`）
			- 涉及定时器（`setTimeout`）
		- 如何测试一个依赖某个 Hook 的组件，确保它在不同返回值下表现正确？
		  logseq.order-list-type:: number
			- 使用 `jest.mock` 模拟该 Hook 的实现
	- 构建与性能
	  collapsed:: true
		- 相比 Webpack，Vite 在开发体验上有哪些优势？
			- 冷启动快：Vite 在开发环境使用原生 ESM， Webpack 在启动前打包整个应用
			- HMR 快：热更新速度与模块总数无关，始终保持轻量快速
		- 如何优化以避免不必要的重复计算？
			- 使用 `useMemo` 缓存计算结果
			- 要知道 `useMemo` 也有成本，只有昂贵的计算才有必要缓存
	- 问题排查与工程思维
	  collapsed:: true
		- 作为团队主力，必须具备**协作规范意识**，下面提到的工具链可看作现代前端**事实标准**，不光“能写功能”，也要能交付“可维护代码”
		- 性能调试：用户反馈页面卡顿，你发现某个组件因 state 状态变化频繁重渲染。你如何定位问题并优化？
		  logseq.order-list-type:: number
		  *要求：属于定位解决问题的能力*
			- 使用 **React DevTools Profiler** 查看渲染耗时和 commit 列表；开启 "Highlight updates when components render" 视觉辅助。
			- 优化：
				- State 下沉：将频繁变化的状态移动到更小的子组件中，避免整树渲染。
				- Memoization：使用 `React.memo` 包裹受影响的子组件，配合 `useCallback` 确保传递的函数引用稳定
				- 防抖/节流：如果状态源于高频事件（如 scroll, input），使用 debounce/throttle
		- 团队中不同成员的代码缩进、引号、分号习惯不同，导致 PR 中混杂大量无关改动。你会如何解决这个问题？
		  logseq.order-list-type:: number
		  *建议掌握，日常开发极高频场景*
			- prettier 自动格式化
			- 配合 ESLint 统一风格和潜在错误检查
			- 编辑器配置保存时自动格式化
			- pre-commit 钩子，确保提交的代码已标准化
		- 你了解过 Conventional Commits 规范吗？这种规范有什么好处？
		  logseq.order-list-type:: number
		  *要求：体现团队协作素养*
			- 自动生成 CHANGELOG
			- 支持语义化版本 (SemVer) 自动发版
			- 提高 Git 历史可读性，便于 code review 和问题回溯
			- 可通过 commitlint + husky 在本地校验 commit 格式
		- 如何确保每次 git commit 的代码都通过了基本检查 (比如类型检查、单元测试、格式化)？
		  logseq.order-list-type:: number
		  *要求：现代前端工程标配*
			- 使用 Husky 设置 Git hook
			- 结合 lint-staged 只对暂存文件运行 ESLint/Prettier
			- 流程：git add -> git commit -> Huksy 触发 -> lint-staged 格式化并检查 -> 失败则阻止提交
			- 强调：不能替代 CI，用于快速反馈、避免低级错误推送到远程仓库
		- 当你推送代码到远程仓库后，团队是如何自动验证代码质量的？你希望 CI 流程包含哪些步骤？
		  logseq.order-list-type:: number
		  *不要求会写配置文件，但需要了解或知道*
			- CI (持续集成) 会在每次 push/PR 时自动运行
				- 安装依赖
				- 类型检查 (tsc --noEmit)
				- 代码 lint (eslint .)
				- 单元测试 (jest 或 vitest)
				- 构建验证
			- 如果任意环节失败，PR 会被标记为失败，不能合并
- ---
- ## 🏠 Personal & Growth
- 22:14 [[HHKB]] 键盘配对 MacOS 的方法
	- 按下 `Fn` + `Q` 进入配对模式
	  logseq.order-list-type:: number
	- 按下 `Fn` + `Control` + `1/2/3/4` 指定设备编号
	  logseq.order-list-type:: number
	- Mac 蓝牙界面搜索设备并连接
	  logseq.order-list-type:: number
	- 等待输入确认码并按下 `Enter` 建
	  logseq.order-list-type:: number
- 22:20 Document Picture-in-Picture API #WebAPI
  collapsed:: true
	- 什么是 Document Picture-in-Picture？
		- Document Picture-in-Picture 是一个浏览器端的 Web API，它允许开发者打开一个**始终置顶**、**由 HTML 内容驱动**的独立小窗口。
	- Document PiP 中的内容可以是**任意 HTML DOM**，具有**完全的交互能力** (比如点击、输入、滚动、拖拽等)，可应用于**计时器**、**番茄钟**、**股票看板**、**视频会议控制台**等场景。
	- 要实现 Document PiP 一般按照以下流程来做：
		- 检测支持：`if ('documentPictureInPicture' in window)`
		  logseq.order-list-type:: number
			- 由于并不是所有浏览器都支持该 API，因此我们在使用该功能前必须要做检测支持。可参考 [caniuse](https://caniuse.com/?search=document-picture-in-picture) 来查看支持该功能的浏览器。
		- 请求窗口：`await window.documentPictureInPicture.requestWindow({ width, height })`
		  logseq.order-list-type:: number
			- 请求窗口时可预先配置窗口的宽、高。
		- 内容填充：向返回的 `win.document.body` 中挂载 DOM。
		  logseq.order-list-type:: number
		- 样式同步：因 PiP 窗口是一个独立的隔离环境，样式不会自动继承，因此需要**手动**将主窗口中的 CSS 样式表复制到 PiP 窗口中。
		  logseq.order-list-type:: number
	- [[React]] 中集成 Document Picture-in-Picture 的方法
		- 使用 `createPortal` 实现组件“传送”，保持组件实例不销毁，状态不丢失。
		- ```tsx
		  // 伪代码架构
		  const App = () => {
		    const [pipWindow, setPipWindow] = useState(null);
		  
		    return (
		      <>
		        {/* 场景1: 普通模式 */}
		        {!pipWindow && <MyComponent />}
		  
		        {/* 场景2: PiP 模式 (通过 Portal 传送) */}
		        {pipWindow && createPortal(
		          <MyComponent />, 
		          pipWindow.document.body
		        )}
		      </>
		    );
		  };
		  ```
	- Document Picture-in-Picture 的限制
		- 生命周期
			- 强绑定：PiP 窗口依附于 Opener (主标签页)，**主页刷新或关闭，PiP 窗口立即关闭**。
			- 应对：主页显示“占位符”，提示用户后台 PiP 正在运行。
		- 窗口尺寸控制
			- User Activation 限制：`window.resizeTo` 必须由**用户手势 (点击/按键) 直接触发**，不能在 `useEffect` 或 `setTimeout` 中任意调用。
			- 浏览器记忆：浏览器会记住上次用户关闭 PiP 窗口时的大小。
				- 现象：代码请求 `height: 32px`，实际打开可能是 `500px`。
				- 应对：采用“状态跟随”策略，不要强行重置状态，而是根据上次的状态自适应。
			- 系统最小高度：操作系统限制窗口最小高度 (通常 > 100px)，请求过小的高度可能不生效。
		- 样式隔离
			- PiP 窗口是全新的 `document`，主窗口的样式不会自动继承到 PiP 窗口生效。
			- 解决方案：遍历并克隆 `styleSheets`。
				- ```ts
				  function copyStyles(targetDoc: Document) {
				    [...document.styleSheets].forEach((sheet) => {
				      try {
				        if (sheet.href) {
				          const link = document.createElement('link');
				          link.rel = 'stylesheet';
				          link.href = sheet.href;
				          targetDoc.head.appendChild(link);
				        } else if (sheet.ownerNode instanceof HTMLStyleElement) {
				          const style = document.createElement('style');
				          style.textContent = sheet.ownerNode.textContent;
				          targetDoc.head.appendChild(style);
				        }
				      } catch (e) {
				        console.warn('Style copy failed', e);
				      }
				    });
				  }
				  ```
	- [[React]] 中使用 Document Picture-in-Picture 最佳实践
		- 不要在关闭 PiP 窗口时重置业务状态 (比如表单的展开/收起)。
		- 配合浏览器“记忆尺寸”特性，如果用户上次是展开状态关闭的 PiP 窗口，下次打开 PiP 窗口时保留展开状态。
		- 在 React 中必须配合 `Portal` 才能实现无缝的状态流转。
		- `resizeTo` 必须在 click handler 等事件内部直接触发才生效。