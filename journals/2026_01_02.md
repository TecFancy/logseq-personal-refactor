- 15:29 [[懂你英语A+]] 口语课：大失所望 (Dialouge) #reading
	- Woman: Did you see all the reviews for our new movie yet?
	  id:: 6958b8cc-0aea-4a82-89f4-f76af47a0dc3
	- Man: Yeah, I was really hoping it would **be a hit**, but it seems like it didn't **live up to the hype** at all.
	  id:: 6958b8cc-ca9a-4835-b6e1-cbe958adfa64
	- Woman: I know, it's like **a slap in the face**.
	  id:: 6958b8cc-b411-4e38-9f1f-aeab84e26311
	- Woman: Remember that zero-gravity fight scene we worked on for weeks?
	  id:: 6958b8cc-28eb-4365-8167-dec1db621f5e
	- Woman: Critics called it "**uninspired**".
	  id:: 6958b8cc-04ee-4ec3-b76b-eae0f5186626
	- Man: Exactly. All those long nights of editing to make the CGI look realistic, **and what for**?
	  id:: 6958b8cc-2a0c-4381-810c-cdc3008965c8
	- Man: **To be left high and dry** with a 2-star rating.
	  id:: 6958b8cc-6204-444b-a161-71960b2c43df
	- Woman: I guess we might have expected too much.
	- Woman: I had a feeling our marketing team oversold it, making the trailers promise more than we delivered.
	- Man: Possibly.
	- Man: It's so crushing to **have your hopes dashed** after putting in our absolute best.
	  id:: 6958b8cc-e2fb-4839-9044-225d31955d97
	- Woman: Reason tells me we should learn from this, but the reality is we won't be financially okay for another attempt.
	- Man: So what should we do now?
	- Woman: Hmm... We need to **take a step back** and assess our options carefully.
	  id:: 6958b8cc-4ec5-481f-b578-3a5c8f4168e8
	- Woman: There might be a way to make our old unfinished projects into something new.
- [[Learn IndexedDB]]
	- 18:52 [[IDB]] 原生初始化 DB 方法 #coding #reading
	  id:: 6956acae-2332-4bd6-9457-5ea1dc9dedd9
	  collapsed:: true
	  :LOGBOOK:
	  CLOCK: [2026-01-02 Fri 19:21:13]--[2026-01-02 Fri 19:34:45] =>  00:13:32
	  :END:
		- ```ts
		  const dbName = 'IDB';
		  const dbVersion = 1; // 版本号必须为整数
		  
		  // 1. 发起请求
		  const request: IDBOpenDBRequest = window.indexedDB.open(dbName, dbVersion);
		  
		  // 2. 处理 Schema 变更
		  request.onupgradeneeded = (event: IDBVersionChangeEvent) => {
		    const db = (event.target as IDBOpenDBRequest).result;
		    console.log(`Upgrading from version ${event.oldVersion} to ${event.newVersion}`);
		    
		    // 检查是否存在，防止重复创建报错
		    if (!db.objectStoreNames.contains('todos')) {
		      // 创建一个名为 'todos' 的表，主键是 'id' (自增)
		      // createObjectStore 只能在这里调用
		      const objectStore = db.createObjectStore('todos', {
		        keyPath: 'id',
		        autoIncrement: true,
		      });
		      
		      // 创建索引，允许通过 'status' 字段查询
		      objectStore.createIndex('by_status', 'status', {
		        unique: false,
		      });
		    }
		  };
		  
		  // 3. 处理成功连接
		  request.onsuccess = (event: Event) => {
		    const db = (event.target as IDBOpenDBRequest).result;
		    console.log(`DB opened successfully!`, db);
		    // 提示：这里通常会将 db 保存到 State 或 Ref 中供后续使用
		  };
		  
		  // 4. 处理错误连接
		  request.onerror = (event: Event) => {
		    console.error(`DB error:`, (event.target as IDBOpenDBRequest).error);
		  };
		  ```
	- 19:34 [[Dexie.js]] 初始化 DB 方法 #coding #reading
	  id:: 6957ad53-105e-4933-8e2f-d0ca281e6b46
	  collapsed:: true
		- ```ts
		  // file: db.ts
		  import Dexie, { type Table } from 'dexie';
		  
		  // 定义数据接口
		  export interface Todo {
		    id?: number;
		    title: string;
		    status: 'don' | 'pending';
		  }
		  
		  // 1. 继承 Dexie 类
		  class IDB extends Dexie {
		    // 定义表的类型提示，便于 TS 自动推导
		    todo!: Table<Todo, number>;
		    
		    constructor() {
		      super('IDB');
		      
		      // 2. 声明 Schema
		      this.version(1).stores({
		        // '++id' 表示主键自增
		        // 'status' 表示索引字段
		        todos: '++id, status',
		      });
		    }
		  }
		  
		  // 实例化
		  export const db = new IDB();
		  ```
	- 20:15 [[IDB]] 原生方法新增一条数据 #coding #reading
	  id:: 69580275-e17f-41f3-a01c-8235000cab67
	  collapsed:: true
		- 确保已经使用原生方法[初始化](((6956acae-2332-4bd6-9457-5ea1dc9dedd9))) DB
		- ```ts
		  interface TodoItem {
		    title: string;
		    status: 'done' | 'pending';
		  }
		  
		  const addTodo = (db: IDBDatabase, todoItem: TodoItem) => {
		    // 必须返回 Promise 才能在 React 中使用 async/await 等待执行完成
		    return new Promise((resolve, reject) => {
		      try {
		        // 1. 开启事务 (Transaction)
		        const tx = db.transaction(['todos'], 'readwrite');
		        
		        // 2. 获取对象仓库
		        const store = tx.objectStore('todo');
		      
		        // 3. 发起“添加”请求
		        // 这里没有传入 id，因为在初始化函数中已经将 id 设置为了 autoIncrement: true
		        const request = store.add(todoItem);
		      
		        // 4. 监听成功事件
		        request.onsuccess = () => {
		          console.log(`Data added: ${request.result}`)
		          resolve(request.result);
		        };
		      
		        // 5. 监听失败事件
		        request.onerror = () => {
		          console.error(`Add failed: ${request.error}`);
		          reject(request.error);
		        };
		      
		        // 6. 实务层面的完成 (可选，监听事务整体提交)
		        tx.complete = () => {
		          // Transaction commited
		        };
		      } catch (error) {
		        reject(error);
		      }
		    });
		  };
		  ```
	- 20:27 使用 [[Dexie.js]] 向 DB 中新增一条数据 #coding #reading
	  collapsed:: true
		- 确保已经使用 Dexie 完成[初始化](((6957ad53-105e-4933-8e2f-d0ca281e6b46)))
		- ```ts
		  import { db, type Todo } from './db';
		  
		  const addTodo = async (todoItem: Omit<Todo, 'id'>) => {
		    try {
		      // 1. 直接调用 add 
		      // Dexie 会自动开启一个 Transaction
		      const id = await db.todos.add(todoItem as Todo);
		      
		      console.log(`Dexie: Data added - ${id}`);
		      return id;
		    } catch (error) {
		      console.error(`Dexie: Add field - ${error}`)
		      throw error;
		    }
		  };
		  ```