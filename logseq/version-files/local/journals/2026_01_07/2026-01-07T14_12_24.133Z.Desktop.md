## 💼 Work Stream
- 09:15 [[CTW]] BPM-A(Team2) daily standup #meeting
- 14:00 [[CTW]] Case Tracker UI review #meeting
  category:: review
  attendees:: Shinly, Diamond, Tomi
- DONE [[CTW]] Document PiP investigation #coding
  collapsed:: true
	- 核心支持能力
		- 完整交互：支持点击、输入、滚动等所有标准网页交互
		- React 兼容：结合 `createPortal` 可将组件“传送到” PiP 窗口，不需要销毁重建
			- 状态保留：表单中已经输入的文字、计数器读数等能保留
			- 响应式更新：主窗口的 state 变化会实时驱动 PiP 窗口内的 UI 更新
		- 动态尺寸调整
			- 支持通过 `resizeTo` 在事件中调整 PiP 窗口大小
			- 窗口尺寸控制：必须由用户手势 (比如 click 事件) 直接触发
				- 不能在 `useEffect` 或异步回调中随意调整 PiP 窗口大小 (浏览器会拦截)
				- 必须直接绑定在 `click` 等事件处理函数中
	- 限制
		- 关闭、刷新主窗口标签，PiP 窗口会强制关闭
		- 浏览器记忆机制
			- 浏览器会优先记住用户上次关闭窗口时的大小和位置，会忽略 `requestWindow` 中的初始配置
				- 比如希望能以高 `32px` 打开窗口，但如果用户上次将窗口拉大到了 `500px`，下次打开依然是 `500px`
				- 方案：不强行重置业务状态，让业务状态适配窗口 (比如上次关闭窗口时展开了表单，下次打开窗口直接显示展开状态的表单)
		- 系统最小高度：操作系统对窗口有强制最小高度 (约 100px - 130px)
			- 初始化配置 32px 高度，实际可能有部分空白
			- 方案：调整最小 panel 的高度
		- 样式隔离
			- 样式不继承
				- PiP 窗口是一个全新的 `window` 上下文，主窗口的 CSS 不会**自动生效**
				- 方案：在打开窗口时，需要手动遍历 `document.styleSheets` 并复制到 PiP 文档的 `<head>` 中
- [[Prepare Interview Materials]] Level 2 (中级开发)
  collapsed:: true
	- **整体要求：不仅能独立完成需求，还能写出可维护的代码，还要理解背后的原理和工程规范。**
	- React 基础
		- 在 TS 中，为什么要避免对组件的 props 使用 any 类型？
		  logseq.order-list-type:: number
			- 失去 TS 的类型检查优势
			- 父组件传参错误（如拼写错误、类型不匹配）时无法在编译期发现
			- 编辑器丢失智能提示
			- 降低开发效率和代码可读性、增加低级错误出现的概率
		- 解释 `useState` 和 `useEffect` 的典型使用场景，并各举一个实际的例子。
		  logseq.order-list-type:: number
			- `useState`：管理组件内部状态
				- 控制 Modal 的 `isOpen`
				- 或表单输入的 `value`
			- `useEffect`：处理副作用
				- 组件挂载后发起 API 请求
				- 手动操作 DOM (如聚焦输入框)
				- 建立/清除定时器。
	- TypeScript
		- 什么时候使用 interface，什么时候使用 type 定义类型？它们在扩展性和可维护性上有什么区别？
		  logseq.order-list-type:: number
			- 很多场景通用两者通用，库开发 interface 便于扩展，复杂类型组合逻辑中用 type
			- Interface
				- 适合定义对象结构、类的实现。支持**声明合并**，可扩展第三方库类型
			- Type
				- 更灵活，适合定义基本类型的别名、联合类型、交叉类型、元组等
		- TS 内置类型中，你最常用的有哪些？从你用过的内置类型中你学到了什么？
		  logseq.order-list-type:: number
			- 常见：`Partial`, `Required`, `Pick`, `Omit`, `Record`, `ReturnType`
			- 理解泛型和映射类型的组合能力，能减少重复代码定义
	- 样式与 SCSS
		- 相比全局 CSS，CSS Module 有哪些优势？
			- 避免命名冲突：自动生成唯一类名，避免污染全局
			- 明确依赖：样式文件与组件一一对应，删除组件时能清楚知道哪些样式也可以删除
	- 单元测试
		- 什么是 Jest 快照测试？它适用于哪些场景？又有哪些局限性？
		  logseq.order-list-type:: number
			- 将组件渲染结果序列化为字符串并保存在文件中，下次测试时对比是否变化
			- 场景
				- 适用于 UI 结构相对稳定
				- 确保重构时不意外改变 DOM 结构
			- 局限
				- 极其脆弱，任何细微改动都会报错
				- 开发者容易养成“无脑更新快照”的坏习惯，导致测试失效
		- 如果 UI 微调导致大量快照失效，你是选择更新快照还是改用其他测试方式？为什么？
		  logseq.order-list-type:: number
			- 如果是预期的 UI 变更，使用 `u` 更新快照；如果逻辑变更但不应该影响 UI 导致的快照的失效，要通过对比排查 Bug
			- 如果快照过于频繁变动导致维护成本过高，可改用基于 React Testing Library 的断言来测试核心交互，而非全量快照
		- 什么时候需要对自定义 Hook 或函数进行 mock？
		  logseq.order-list-type:: number
			- 涉及外部依赖（API 请求）
			- 涉及不确定性（如 `Date.now()`, `Math.random()`）
			- 涉及定时器（`setTimeout`）
		- 如何测试一个依赖某个 Hook 的组件，确保它在不同返回值下表现正确？
		  logseq.order-list-type:: number
			- 使用 `jest.mock` 模拟该 Hook 的实现
	- 构建与性能
		- 相比 Webpack，Vite 在开发体验上有哪些优势？
			- 冷启动快：Vite 在开发环境使用原生 ESM， Webpack 在启动前打包整个应用
			- HMR 快：热更新速度与模块总数无关，始终保持轻量快速
		- 如何优化以避免不必要的重复计算？
			- 使用 `useMemo` 缓存计算结果
			- 要知道 `useMemo` 也有成本，只有昂贵的计算才有必要缓存
	- 问题排查与工程思维
		- 作为团队主力，必须具备**协作规范意识**，下面提到的工具链可看作现代前端**事实标准**，不光“能写功能”，也要能交付“可维护代码”
		- 性能调试：用户反馈页面卡顿，你发现某个组件因 state 状态变化频繁重渲染。你如何定位问题并优化？
		  logseq.order-list-type:: number
		  *要求：属于定位解决问题的能力*
			- 使用 **React DevTools Profiler** 查看渲染耗时和 commit 列表；开启 "Highlight updates when components render" 视觉辅助。
			- 优化：
				- State 下沉：将频繁变化的状态移动到更小的子组件中，避免整树渲染。
				- Memoization：使用 `React.memo` 包裹受影响的子组件，配合 `useCallback` 确保传递的函数引用稳定
				- 防抖/节流：如果状态源于高频事件（如 scroll, input），使用 debounce/throttle
		- 团队中不同成员的代码缩进、引号、分号习惯不同，导致 PR 中混杂大量无关改动。你会如何解决这个问题？
		  logseq.order-list-type:: number
		  *建议掌握，日常开发极高频场景*
			- prettier 自动格式化
			- 配合 ESLint 统一风格和潜在错误检查
			- 编辑器配置保存时自动格式化
			- pre-commit 钩子，确保提交的代码已标准化
		- 你了解过 Conventional Commits 规范吗？这种规范有什么好处？
		  logseq.order-list-type:: number
		  *要求：体现团队协作素养*
			- 自动生成 CHANGELOG
			- 支持语义化版本 (SemVer) 自动发版
			- 提高 Git 历史可读性，便于 code review 和问题回溯
			- 可通过 commitlint + husky 在本地校验 commit 格式
		- 如何确保每次 git commit 的代码都通过了基本检查 (比如类型检查、单元测试、格式化)？
		  logseq.order-list-type:: number
		  *要求：现代前端工程标配*
			- 使用 Husky 设置 Git hook
			- 结合 lint-staged 只对暂存文件运行 ESLint/Prettier
			- 流程：git add -> git commit -> Huksy 触发 -> lint-staged 格式化并检查 -> 失败则阻止提交
			- 强调：不能替代 CI，用于快速反馈、避免低级错误推送到远程仓库
		- 当你推送代码到远程仓库后，团队是如何自动验证代码质量的？你希望 CI 流程包含哪些步骤？
		  logseq.order-list-type:: number
		  *不要求会写配置文件，但需要了解或知道*
			- CI (持续集成) 会在每次 push/PR 时自动运行
				- 安装依赖
				- 类型检查 (tsc --noEmit)
				- 代码 lint (eslint .)
				- 单元测试 (jest 或 vitest)
				- 构建验证
			- 如果任意环节失败，PR 会被标记为失败，不能合并
- ---
- ## 🏠 Personal & Growth
- LATER 整理出 Document Picture-in-Picture 笔记 #reading #coding 
  SCHEDULED: <2026-01-11 Sun>
- HHKB 键盘配对 MacOS 的方法
	- 按下 `Fn`
	  logseq.order-list-type:: number