- 15:29 [[懂你英语A+]] 口语课：大失所望 (Dialouge) #reading
	- Woman: Did you see all the reviews for our new movie yet?
	  id:: 6958b8cc-0aea-4a82-89f4-f76af47a0dc3
	- Man: Yeah, I was really hoping it would **be a hit**, but it seems like it didn't **live up to the hype** at all.
	  id:: 6958b8cc-ca9a-4835-b6e1-cbe958adfa64
	  collapsed:: true
		- 我原本真心希望能大火，但看来它完全没有达到宣传预期的那样（盛名之下其实难副）。
	- Woman: I know, it's like **a slap in the face**.
	  id:: 6958b8cc-b411-4e38-9f1f-aeab84e26311
	  collapsed:: true
		- 我懂，这种感觉简直就像被人狠狠扇了一耳光（奇耻大辱/极度失望）。
	- Woman: Remember that zero-gravity fight scene we worked on for weeks?
	  id:: 6958b8cc-28eb-4365-8167-dec1db621f5e
	- Woman: Critics called it "**uninspired**".
	  id:: 6958b8cc-04ee-4ec3-b76b-eae0f5186626
	- Man: Exactly. All those long nights of editing to make the CGI look realistic, **and what for**?
	  id:: 6958b8cc-2a0c-4381-810c-cdc3008965c8
	  collapsed:: true
		- 没错。那些为了让 CGI (电脑特效) 看起来逼真而熬过的漫漫长夜，到底是为了什么？（意指：最后图什么呢？完全白费力气）。
	- Man: **To be left high and dry** with a 2-star rating.
	  id:: 6958b8cc-6204-444b-a161-71960b2c43df
	  collapsed:: true
		- 留我们孤立无援，只拿到一个两星的差评。（字面：把船搁浅在干岸上）。
	- Woman: I guess we might have **expected too much**.
	  id:: 6958b8cc-47bb-4644-a2e1-7bfa8cbfde07
	  collapsed:: true
		- 我想（也许）是我们之前期望太高了。
	- Woman: I had a feeling our marketing team oversold it, making the trailers **promise more than we delivered**.
	  id:: 6958b8cc-759c-4a1a-8ad6-58d70469c1a0
	  collapsed:: true
		- 我有一种感觉，是我们的营销团队宣传过头了（吹得天花乱坠），导致预告片许下的承诺超过了我们实际交付的水准。
		- oversell: 过分吹嘘、夸大其词
		- promise more than we delivered: 经典的商业痛点描述，即“承诺 > 交付” (Over-promise and under-deliver)。
	- Man: Possibly.
	- Man: It's so crushing to **have your hopes dashed** after putting in our absolute best.
	  id:: 6958b8cc-e2fb-4839-9044-225d31955d97
	  collapsed:: true
		- 在我们已经竭尽全力（做到绝对最好）之后，这种希望破灭的感觉真是太让人崩溃/深受打击了。
		- Crushing: 原意是“压碎/碾碎”。用作形容词时，形容那种“沉重得让人喘不过气”的极度失望或挫败感。
		- Put in our absolute best: 这里的 `put in` (投入) 搭配 `best`，比简单的 `do my best` 更强调“投入的过程”和“毫无保留的态度”。
	- Woman: Reason tells me we should learn from this, but the reality is we won't be financially okay for another attempt.
	  id:: 6958b8cc-4503-4869-848b-d2577626900b
		- 理智告诉我，我们应该从中吸取教训（卷土重来），但现实是，我们的资金状况不允许我们再试一次了。
		- Reason tells me...: 这是一个拟人化表达（Personification）。将“理智”作为主语，显得更加客观、冷静。
	- Man: So what should we do now?
	- Woman: Hmm... We need to **take a step back** and assess our options carefully.
	  id:: 6958b8cc-4ec5-481f-b578-3a5c8f4168e8
	  collapsed:: true
		- 我们需要退一步（跳出当前局限），仔细评估我们的选项。
	- Woman: There might be a way to make our old unfinished projects into something new.
	  id:: 6958b8cc-fe13-4c48-ad83-6c8d99ff95f9
		- 也许有个办法能把我们那些未完成的旧项目改造成一些新东西（变废为宝）。
- [[Learn IndexedDB]]
	- 18:52 [[IDB]] 原生初始化 DB 方法 #coding #reading
	  id:: 6956acae-2332-4bd6-9457-5ea1dc9dedd9
	  collapsed:: true
	  :LOGBOOK:
	  CLOCK: [2026-01-02 Fri 19:21:13]--[2026-01-02 Fri 19:34:45] =>  00:13:32
	  :END:
		- ```ts
		  const dbName = 'IDB';
		  const dbVersion = 1; // 版本号必须为整数
		  
		  // 1. 发起请求
		  const request: IDBOpenDBRequest = window.indexedDB.open(dbName, dbVersion);
		  
		  // 2. 处理 Schema 变更
		  request.onupgradeneeded = (event: IDBVersionChangeEvent) => {
		    const db = (event.target as IDBOpenDBRequest).result;
		    console.log(`Upgrading from version ${event.oldVersion} to ${event.newVersion}`);
		    
		    // 检查是否存在，防止重复创建报错
		    if (!db.objectStoreNames.contains('todos')) {
		      // 创建一个名为 'todos' 的表，主键是 'id' (自增)
		      // createObjectStore 只能在这里调用
		      const objectStore = db.createObjectStore('todos', {
		        keyPath: 'id',
		        autoIncrement: true,
		      });
		      
		      // 创建索引，允许通过 'status' 字段查询
		      objectStore.createIndex('by_status', 'status', {
		        unique: false,
		      });
		    }
		  };
		  
		  // 3. 处理成功连接
		  request.onsuccess = (event: Event) => {
		    const db = (event.target as IDBOpenDBRequest).result;
		    console.log(`DB opened successfully!`, db);
		    // 提示：这里通常会将 db 保存到 State 或 Ref 中供后续使用
		  };
		  
		  // 4. 处理错误连接
		  request.onerror = (event: Event) => {
		    console.error(`DB error:`, (event.target as IDBOpenDBRequest).error);
		  };
		  ```
	- 19:34 [[Dexie.js]] 初始化 DB 方法 #coding #reading
	  id:: 6957ad53-105e-4933-8e2f-d0ca281e6b46
	  collapsed:: true
		- ```ts
		  // file: db.ts
		  import Dexie, { type Table } from 'dexie';
		  
		  // 定义数据接口
		  export interface Todo {
		    id?: number;
		    title: string;
		    status: 'don' | 'pending';
		  }
		  
		  // 1. 继承 Dexie 类
		  class IDB extends Dexie {
		    // 定义表的类型提示，便于 TS 自动推导
		    todo!: Table<Todo, number>;
		    
		    constructor() {
		      super('IDB');
		      
		      // 2. 声明 Schema
		      this.version(1).stores({
		        // '++id' 表示主键自增
		        // 'status' 表示索引字段
		        todos: '++id, status',
		      });
		    }
		  }
		  
		  // 实例化
		  export const db = new IDB();
		  ```
	- 20:15 [[IDB]] 原生方法新增一条数据 #coding #reading
	  id:: 69580275-e17f-41f3-a01c-8235000cab67
	  collapsed:: true
		- 确保已经使用原生方法[初始化](((6956acae-2332-4bd6-9457-5ea1dc9dedd9))) DB
		- ```ts
		  interface TodoItem {
		    title: string;
		    status: 'done' | 'pending';
		  }
		  
		  const addTodo = (db: IDBDatabase, todoItem: TodoItem) => {
		    // 必须返回 Promise 才能在 React 中使用 async/await 等待执行完成
		    return new Promise((resolve, reject) => {
		      try {
		        // 1. 开启事务 (Transaction)
		        const tx = db.transaction(['todos'], 'readwrite');
		        
		        // 2. 获取对象仓库
		        const store = tx.objectStore('todo');
		      
		        // 3. 发起“添加”请求
		        // 这里没有传入 id，因为在初始化函数中已经将 id 设置为了 autoIncrement: true
		        const request = store.add(todoItem);
		      
		        // 4. 监听成功事件
		        request.onsuccess = () => {
		          console.log(`Data added: ${request.result}`)
		          resolve(request.result);
		        };
		      
		        // 5. 监听失败事件
		        request.onerror = () => {
		          console.error(`Add failed: ${request.error}`);
		          reject(request.error);
		        };
		      
		        // 6. 实务层面的完成 (可选，监听事务整体提交)
		        tx.complete = () => {
		          // Transaction commited
		        };
		      } catch (error) {
		        reject(error);
		      }
		    });
		  };
		  ```
	- 20:27 使用 [[Dexie.js]] 向 DB 中新增一条数据 #coding #reading
	  collapsed:: true
		- 确保已经使用 Dexie 完成[初始化](((6957ad53-105e-4933-8e2f-d0ca281e6b46)))
		- ```ts
		  import { db, type Todo } from './db';
		  
		  const addTodo = async (todoItem: Omit<Todo, 'id'>) => {
		    try {
		      // 1. 直接调用 add 
		      // Dexie 会自动开启一个 Transaction
		      const id = await db.todos.add(todoItem as Todo);
		      
		      console.log(`Dexie: Data added - ${id}`);
		      return id;
		    } catch (error) {
		      console.error(`Dexie: Add field - ${error}`)
		      throw error;
		    }
		  };
		  ```