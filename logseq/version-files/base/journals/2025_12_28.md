- 15:41 [[懂你英语A+]] 听力课：情感危机 (Dialouge) #reading
	- My friend Sandy has been in a long-distance relationship for three years.
	- A few months ago, her boyfriend, Emmett, moved in with her. And now it seems their relationship is **on the rocks**.
	- I always admired my friend's relationship. Long distance is hard, but they seemed pretty **content**.
	- My friend also has a lot of hobbies, and had lots of time for her interests. It seemed like a very **beneficial** situation for her.
	- But now things have changed. Emmett isn't as active as she is, and likes to spend time at home together.
	- And their schedules are different, too. My friend likes to go to bed early, but her boyfriend like to stay up late.
	- They've wanted to live together for a long time. But this situation is not something that they planned **for**.
	- Still, I hope they're **patient** with each other.
	- It takes time to build a relationship. It would be sad if they just threw it away.
- DONE 23:04 梳理 [[Learn IndexedDB]] 第三方库 [[Dexie.js]] 的最佳实践 #reading
  id:: 695146f7-d52b-409e-8de0-cf6fab7f8596
  :LOGBOOK:
  CLOCK: [2025-12-28 Sun 23:06:03]--[2025-12-28 Sun 23:18:40] =>  00:12:37
  :END:
	- 掌握 Promise：显式返回 (Return)
	  logseq.order-list-type:: number
	  collapsed:: true
		- 在 Promise 链中显式返回结果或另一个 Promise，以确保调用者可以正确消费数据。
		- ```js
		  function getFriendId() {
		    // 必须 return 整个链条，否则外部无法得知操作何时完成
		    return db.friends.where('name').startsWith('A').first()
		      .then(friend => {
		        return friend.id; // 必须 return 值，以便下一个 .then 接收
		      });
		  }
		  ```
	- 明智捕获：事务内的错误传播
	  logseq.order-list-type:: number
	  collapsed:: true
		- 在事务内部，除非要手动处理错误并继续，否则**不要**捕获错误；如果为了调试记录日志，必须使用 `throw err` 重新抛出，否则事务会强制提交。
		- ```js
		  async function safeAdd() {
		    try {
		      await db.transaction('rw', db.friends, async () => {
		        try {
		          await db.friends.add({ name: 'Foo' });
		        } catch (err) {
		          console.error("添加失败，记录日志...");
		          throw err; // 必须重新抛出，否则事务会认为错误已处理并提交
		        }
		      });
		    } catch (error) {
		      // 在顶层（如 UI 逻辑）统一捕获并展示给用户
		      console.log("最终捕获到事务错误:", error);
		    }
		  }
		  ```
	- 使用事务：封装多个操作
	  logseq.order-list-type:: number
	  collapsed:: true
		- 当需要执行超过一个操作时，应使用事务来保证原子性和性能。
		- ```js
		  // 同时添加朋友和宠物，若宠物添加失败，朋友也将回滚
		  db.transaction('rw', db.friends, db.pets, async () => {
		    const id = await db.friends.add({ name: 'Mans' });
		    await db.pets.add({ name: 'Josephina', ownerId: id });
		    // 这里可以不处理单个操作的 Promise，事务块会统一处理
		  }).catch(err => {
		    console.error("事务整体回滚:", err);
		  });
		  ```
		- Q：在这个代码块中需要 throw err 吗？
		- A：**不需要**手动使用 `throw err`。
			- 自动传播： 在这个 `async` 匿名函数中，没有使用 `try/catch` 块来捕获错误。因此，如果 `await` 后面的数据库操作失败，它抛出的异常会直接向上冒泡传递给 Dexie。
			- 自动回滚： Dexie 的事务块会自动监听内部未被捕获的异常。一旦检测到错误，它会自动中止（abort）整个事务并回滚数据,。
			- 统一捕获： 代码末尾的 `.catch()` 已经负责捕获整个事务（包括其中任何一个操作）抛出的错误。
		- Q：什么时候必须使用 throw err？
		- A：只有当为了记录日志而在事务**内部**编写了 `try/catch` 时，才必须重新抛出错误。
	- 异步限制：使用全局 Promise
	  logseq.order-list-type:: number
	  collapsed:: true
		- 在事务内部，严禁等待非 IDB 的异步 API（如 `setTimeout` 或 `fetch`），并确保使用全局 Promise 对象。
		- ```js
		  db.transaction('r', db.friends, async () => {
		    // 正确：使用全局 Promise 处理并行请求
		    await Promise.all([
		      db.friends.where('age').above(20).toArray(),
		      db.friends.where('name').startsWith('A').toArray()
		    ]);
		  
		    // 错误：不要在这里使用 await setTimeout(...)，否则会导致事务关闭
		  });
		  ```